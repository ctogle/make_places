
import mp_vector cv
import mp_utils mpu

import numpy as np
import pdb

# this is a reimplementation of terrain generation
#
# use a generator of the sierpenski gasket on a unit square to generate new
# triangles
#
# take as input:
#   a set of fixed pts to fit terrain to
#   a set of polygons to cut in the terrain as holes
#   a set of pts to determine where terrain should be made
#       should generate mesh to provide terrain up to a certain radius
#       from the line generated by this set of pts
#   a target length for the length of an edge of a polygon in the mesh
#       unit gaskets are scaled so that edge distance is near length (!=)
#   a target length for the edge of a piece of mesh, which represents one
#       object in grit
#   should generate lods which are properly stitched, and non lods
#       should return the kwargs to make the primitives



def some_input():
    ls = [5, 10, 15]
    ws = [2, 4, 6, 8]
    base = cv.vector(50,50,0)
    fixed_pts = []
    for sq in range(5):
        pt = base.copy().translate_x(sq*25).translate_y(sq*10)
        l,w = rm.choice(ls,ws)
        corners = mpu.make_corners(pt,l,w,0)
        fixed_pts.extend(corners)

    hole_corners = [pt.copy() for pt in fixed_pts]

    region_pts = []
    for lpt in range(5):
        pt = cv.zero().translate_x(lpt*100)
        region_pts.append(pt)

    target_polygon_edge_length = 10
    target_primitive_edge_length = 25

    theinput = {
        'fixed_pts':fixed_pts, 
        'hole_pts':hole_corners, 
        'region_pts':region_pts, 
        'polygon_edge_length':target_polygon_edge_length, 
        'primitive_edge_length':target_primitive_edge_length, 
            }
    return theinput

def find_extremes_y(pts):
    lo = pts[0]
    hi = pts[0]
    for pt in pts[1:]:
        if pt.y < lo.y: lo = pt
        if pt.y > hi.y: hi = pt
    return lo,hi

def find_extremes_x(pts):
    lo = pts[0]
    hi = pts[0]
    for pt in pts[1:]:
        if pt.x < lo.x: lo = pt
        if pt.x > hi.x: hi = pt
    return lo,hi

def sweep_search(pts,center):
    # this will behave oddly when `which` would
    #  be a colinear set
    cv.translate_coords(pts,center.flip())
    which = center
    pang = 2*np.pi
    pcnt = len(pts)
    for adx in range(pcnt):
        pt = pts[adx]
        if pt is center: continue
        tpang = cv.angle_from_xaxis_xy(pt)
        if tpang < pang:
            pang = tpang
            which = pt
    cv.translate_coords(pts,center.flip())
    return which

def pts_to_convex_xy(pts):
    # return the corners of the polygon, a subset of pts
    # it could be that pts is all one point or is colinear
    new = find_extremes_x(pts)[1]
    shape = []
    while not new in shape:
        shape.append(new)
        new = sweep_search(pts,new)
    return shape

def region_pts_to_boundary(rpts, radius = 100):
    # draw a convex polygon enclosing rpts; inflate by a radius
    convex = pts_to_convex(rpts)



def test():
    someinput = some_input()
    convex = pts_to_convex(someinput['region_pts'])
    pdb.set_trace()













